#include "vulkanWrapper.h"

void createSwapChain(const LogicalDevice &device,
                     VkSurfaceKHR        surface,
                     VkExtent2D          &requiredExtent,
                     SwapChain           &swapChain)
{
    SwapChainSupportDetails swapChainSupport = querySwapChainSupport  (device.physicalDevice, surface);
    VkSurfaceFormatKHR      surfaceFormat    = chooseSwapSurfaceFormat(swapChainSupport.formats);
    VkPresentModeKHR        presentMode      = chooseSwapPresentMode  (swapChainSupport.presentModes);
    
   
    VkExtent2D actualExtent = chooseSwapExtent(requiredExtent, swapChainSupport.capabilities);

    uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;

    //maxImageCount равный нулю означает что здесь нет ограничения на количество изображений
    if(swapChainSupport.capabilities.maxImageCount > 0  &&
       imageCount > swapChainSupport.capabilities.maxImageCount)
    {
        imageCount = swapChainSupport.capabilities.maxImageCount;
    }

    VkSwapchainCreateInfoKHR createInfo{};
    createInfo.sType   = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    createInfo.surface = surface;

    createInfo.minImageCount    = imageCount;
    createInfo.imageFormat      = surfaceFormat.format;
    createInfo.imageColorSpace  = surfaceFormat.colorSpace;
    createInfo.imageExtent      = actualExtent;
    createInfo.imageArrayLayers = 1; // Количество слоев на которых будут располагаться

    // данная цепочка показа предназначается непосредственно для рисования прямо в нее
    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

    QueueFamilyIndices indices    = findQueueFamilies(device.physicalDevice, surface);
    uint32_t queueFamilyIndices[] = {indices.graphicsFamily.value(), indices.presentFamily.value()};

    if(indices.graphicsFamily != indices.presentFamily)
    {
        createInfo.imageSharingMode      = VK_SHARING_MODE_CONCURRENT;
        createInfo.queueFamilyIndexCount = 2;
        createInfo.pQueueFamilyIndices   = queueFamilyIndices;
    }
    else
    {
        createInfo.imageSharingMode      = VK_SHARING_MODE_EXCLUSIVE;
        createInfo.queueFamilyIndexCount = 0; // Optional
        createInfo.pQueueFamilyIndices   = nullptr; // Optional
    }

    createInfo.preTransform   = swapChainSupport.capabilities.currentTransform;
    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    createInfo.presentMode    = presentMode;
    createInfo.clipped        = VK_TRUE;

    createInfo.oldSwapchain = VK_NULL_HANDLE;

    if(vkCreateSwapchainKHR(device.handle, &createInfo, nullptr, &swapChain.handle) != VK_SUCCESS)
        throw std::runtime_error("failed to create swap chain!");

    vkGetSwapchainImagesKHR(device.handle, swapChain.handle, &imageCount, nullptr);

    swapChain.images.resize(imageCount);
    vkGetSwapchainImagesKHR(device.handle, swapChain.handle, &imageCount, swapChain.images.data());

    createImageViews(device, swapChain);

    swapChain.imageFormat = surfaceFormat.format;
    swapChain.extent      = actualExtent;
}


VkRenderPass createRenderPass(const LogicalDevice &device,
                              VkFormat            swapChainImageFormat)
{
    VkAttachmentDescription colorAttachment;
    fillColorAttachmentDescription(colorAttachment);
    colorAttachment.format = swapChainImageFormat;


    VkAttachmentDescription depthAttachment;
    fillDepthAttachmentDescription(depthAttachment);
    depthAttachment.format = findDepthFormat(device.physicalDevice);


    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0; // индекс attachment на которое мы ссылаемся
    // для каких целей будет использоваться этот attachment непосредственно сейчас
    // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL - оптимизорован для рисования в него
    colorAttachmentRef.layout     = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;


    VkAttachmentReference depthAttachmentRef{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout     = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;


    // описание текущего подпрохода
    VkSubpassDescription subpass{};
    // чем является данный проход
    // VK_PIPELINE_BIND_POINT_GRAPHICS - данный проход работает с графикой
    // VK_PIPELINE_BIND_POINT_COMPUTE - данный проход работает с вычислениями
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    // индекс attachment'а это и есть слой на который мы рисуем во время работы с шейдером
    // layout(location = 0) out vec4 outColor
    subpass.colorAttachmentCount    = 1;
    subpass.pColorAttachments       = &colorAttachmentRef;
    subpass.pDepthStencilAttachment = &depthAttachmentRef;


    VkSubpassDependency dependency{};
    // индекс подпрохода для которого мы настраиваем зависимости
    // VK_SUBPASS_EXTERNAL описывает неявные подпроходы которые происходят до или после 
    // нашего render pass в зависимости от того расположен он в srcSubpass или dstSubpass
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;

    // индекс выходного подпрохода. Подпроход у нас один единственный и его индекст равен 0
    dependency.dstSubpass = 0;
    //dstSubpass всегда должен быть больше чем srcSubpass во избежание зацикливания в графе зависимостей

    // здесь мы описываем то чего мы ждем прежде чем начать и на какой стадии мы этого ждем
    dependency.srcStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | 
                               VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;

    dependency.dstStageMask  = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | 
                               VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;

    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT          | 
                               VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;


    // В один проход может быть помещено несколько приложений:
    // pInputAttachments: это приложение будет использоваться как ввод для шейдеров
    // pResolveAttachments : это приложение используется для мультисемплинга
    // pDepthStencilAttachment : это прикрепление нужно для карты глубин и трафарета
    // pPreserveAttachments : этот слой не используется во время текущего прохода, 
    // но его данные должны быть приготовленны к использованию
    std::array<VkAttachmentDescription, 2> attachments = {colorAttachment, depthAttachment};

    VkRenderPassCreateInfo renderPassInfo{};
    renderPassInfo.sType           = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
    renderPassInfo.pAttachments    = attachments.data();
    renderPassInfo.subpassCount    = 1;
    renderPassInfo.pSubpasses      = &subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies   = &dependency;


    VkRenderPass renderPass;
    if(vkCreateRenderPass(device.handle, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS)
        throw std::runtime_error("failed to create render pass!");

    return renderPass;
}


///////////////////////////////////////////////////////////

void createDescriptorSetLayout(VkDevice              logicalDevice, 
                               VkDescriptorSetLayout &descriptorSetLayout)
{
    VkDescriptorSetLayoutBinding uboLayoutBinding{};
    uboLayoutBinding.binding         = 0;
    uboLayoutBinding.descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
    // каким стадиям будет доступно данное прикрепление?
    // можно добавить несколько стадий используя |
    // или VK_SHADER_STAGE_ALL_GRAPHICS если данное прикрепление требуется
    // на всех стадиях
    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;

    uboLayoutBinding.pImmutableSamplers = nullptr; // Optional

    VkDescriptorSetLayoutBinding samplerLayoutBinding{};
    samplerLayoutBinding.binding            = 1;
    samplerLayoutBinding.descriptorCount    = 1;
    samplerLayoutBinding.descriptorType     = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    samplerLayoutBinding.pImmutableSamplers = nullptr;
    samplerLayoutBinding.stageFlags         = VK_SHADER_STAGE_FRAGMENT_BIT;

    std::array<VkDescriptorSetLayoutBinding, 2> bindings = {uboLayoutBinding, samplerLayoutBinding};

    VkDescriptorSetLayoutCreateInfo layoutInfo{};
    layoutInfo.sType        = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
    layoutInfo.pBindings    = bindings.data();

    if(vkCreateDescriptorSetLayout(logicalDevice, &layoutInfo, nullptr, &descriptorSetLayout) != VK_SUCCESS)
        throw std::runtime_error("failed to create descriptor set layout!");
}

void createGraphicsPipeline(VkDevice              logicalDevice,
                            VkExtent2D            swapChainExtent,
                            VkRenderPass          renderPass,
                            VkPipelineLayout      &pipelineLayout,
                            VkPipeline            &graphicsPipeline,
                            VkDescriptorSetLayout &descriptorSetLayout)
{
    auto vertShaderCode = readFile("shaders/bin/vert.spv");
    auto fragShaderCode = readFile("shaders/bin/frag.spv");
    // надо чекнуть размер файлов что все загружается

    VkShaderModule vertShaderModule = createShaderModule(logicalDevice, vertShaderCode);
    VkShaderModule fragShaderModule = createShaderModule(logicalDevice, fragShaderCode);

    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
    vertShaderStageInfo.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage  = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName  = "main"; // точка входа

    // опциональный параметр, который позволяет передавать некоторые значения в шейдер
    // опираясь на эти значения шейдер может менять свое поведение
    vertShaderStageInfo.pSpecializationInfo = nullptr;


    VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
    fragShaderStageInfo.sType  = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage  = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName  = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};


    //////////////////////// VERTEX INPUT STAGE ////////////////////////

    auto bindingDescription    = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType                           = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexBindingDescriptionCount   = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.pVertexBindingDescriptions      = &bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions    = attributeDescriptions.data();
    
    ////////////////////////////////////////////////////////////////////


    //////////////////////// INPUT ASSEMBLY STAGE ////////////////////////

    VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
    inputAssembly.sType    = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;

    //////////////////////////////////////////////////////////////////////


    VkViewport viewport{};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width  = (float) swapChainExtent.width;
    viewport.height = (float) swapChainExtent.height;
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    VkRect2D scissor{};
    scissor.offset = {0, 0};
    scissor.extent = swapChainExtent;

    //////////////////////// VIEWPORT SETUP ////////////////////////

    VkPipelineViewportStateCreateInfo viewportState{};
    viewportState.sType         = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports    = &viewport;
    viewportState.scissorCount  = 1;
    viewportState.pScissors     = &scissor;
    //наличие несколких viewport или scissors требует раширение
    
    /////////////////////////////////////////////////////////////////


    //////////////////////// RASTERIZER STAGE ////////////////////////

    VkPipelineRasterizationStateCreateInfo rasterizer{};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE; // VK_TRUE требует расширения

    // отключение этапа растеризации. Если VK_TRUE, то 
    // во framebuffer вообще ничего не будет записано
    rasterizer.rasterizerDiscardEnable = VK_FALSE;

    // определяет каким образом будет обрабатываться каждый полигон
    // в нашем случае мы заполняем его целиком
    // VK_POLYGON_MODE_LINE  - будут рисоваться только линии
    // VK_POLYGON_MODE_POINT - будут рисоваться только точки
    // VK_POLYGON_MODE_LINE и VK_POLYGON_MODE_POINT требует включение расширения
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;

    // определяет толщину линий, которыми связваются точки.
    // любая толщина больше 1 требует включение расширения
    rasterizer.lineWidth = 1.0f;

    // определяет какие треугольники будут отбрасываться при растеризации
    // VK_CULL_MODE_BACK_BIT - означает что мы отбрасываем все треугольники, 
    // которые находятся с задней стороны модели
    rasterizer.cullMode  = VK_CULL_MODE_BACK_BIT;

    // определяет в какую сторону мы движемся, когда индексируем вершины полигона, 
    // который смотрит вперед
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;


    rasterizer.depthBiasEnable         = VK_FALSE;
    rasterizer.depthBiasConstantFactor = 0.0f; // Optional
    rasterizer.depthBiasClamp          = 0.0f; // Optional
    rasterizer.depthBiasSlopeFactor    = 0.0f; // Optional
    ////////////////////////////////////////////////////////////////////////


    //////////////////////// MULTISAMPLING STAGE ////////////////////////

    VkPipelineMultisampleStateCreateInfo multisampling{};
    multisampling.sType                 = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable   = VK_FALSE; 
    multisampling.rasterizationSamples  = VK_SAMPLE_COUNT_1_BIT;
    multisampling.minSampleShading      = 1.0f;     // Optional
    multisampling.pSampleMask           = nullptr;  // Optional
    multisampling.alphaToCoverageEnable = VK_FALSE; // Optional
    multisampling.alphaToOneEnable      = VK_FALSE; // Optional

    /////////////////////////////////////////////////////////////////////

    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable       = VK_TRUE;
    // должен ли фрагмент, который прошел тест глубины записаться как самый ближний
    depthStencil.depthWriteEnable      = VK_TRUE;
    depthStencil.depthCompareOp        = VK_COMPARE_OP_LESS;

    // позволяет определить окно в рамки которого глубина фрагмента должна попадать чтобы пройти тест
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds        = 0.0f; // Optional
    depthStencil.maxDepthBounds        = 1.0f; // Optional

    depthStencil.stencilTestEnable = VK_FALSE;
    depthStencil.front             = {}; // Optional
    depthStencil.back              = {}; // Optional

    //////////////////////// COLOR ATTACHMENT STAGE ////////////////////////

    VkPipelineColorBlendAttachmentState colorBlendAttachment{};
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | 
                                          VK_COLOR_COMPONENT_G_BIT | 
                                          VK_COLOR_COMPONENT_B_BIT | 
                                          VK_COLOR_COMPONENT_A_BIT;

    // здесь очень много параметров с которыми можно поиграться чтобы настроить смешение цветов
    colorBlendAttachment.blendEnable = VK_TRUE;

    // мы просто складываем два цвета, опираясь на прозрачность
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp        = VK_BLEND_OP_ADD;

    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.alphaBlendOp        = VK_BLEND_OP_ADD;

    // finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;
    // finalColor.a = newAlpha.a;

    VkPipelineColorBlendStateCreateInfo colorBlending{};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;

    // будем ли мы использовать логические операции при смешивании цветов
    // colorBlending.logicOpEnable == VK_FALSE автоматически отключает
    // colorBlendAttachment.blendEnable
    // Таким образом мы можем смешивать цвета либо используя только логические операции, либо
    // обычные математические операции вроде сложения
    // должен быть включен и настроен хотя бы один метод смешивания. 
    // Иначе во framebuffer не попадут никакие данные
    colorBlending.logicOpEnable     = VK_FALSE;
    colorBlending.logicOp           = VK_LOGIC_OP_COPY; // Optional
    colorBlending.attachmentCount   = 1;
    colorBlending.pAttachments      = &colorBlendAttachment;
    colorBlending.blendConstants[0] = 0.0f; // Optional
    colorBlending.blendConstants[1] = 0.0f; // Optional
    colorBlending.blendConstants[2] = 0.0f; // Optional
    colorBlending.blendConstants[3] = 0.0f; // Optional

    ////////////////////////////////////////////////////////////////////////

    // Некоторые настройки pipeline, такие как размер viewport, толщина линий и blendConstants 
    // можно настраивать на ходу, не пересоздавая весь pipeline
    VkDynamicState dynamicStates[] = {
        VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_LINE_WIDTH
    };

    VkPipelineDynamicStateCreateInfo dynamicState{};
    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicState.dynamicStateCount = 2;
    dynamicState.pDynamicStates    = dynamicStates;

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType          = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts    = &descriptorSetLayout;

    pipelineLayoutInfo.pushConstantRangeCount = 0;       // Optional
    pipelineLayoutInfo.pPushConstantRanges    = nullptr; // Optional



    if(vkCreatePipelineLayout(logicalDevice, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS)
        throw std::runtime_error("failed to create pipeline layout!");

    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    
    // описываем количество стадий с использованием шейдеров и прилагаем описания самих стадий
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages    = shaderStages;

    // передаем ссылки на описания всех стадий, перечисленных выше
    pipelineInfo.pVertexInputState   = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState      = &viewportState;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState   = &multisampling;
    pipelineInfo.pDepthStencilState  = &depthStencil;
    pipelineInfo.pColorBlendState    = &colorBlending;
    pipelineInfo.pDynamicState       = nullptr; // Optional

    pipelineInfo.layout = pipelineLayout;

    pipelineInfo.renderPass = renderPass;
    pipelineInfo.subpass    = 0; // index of subpass

    // pipelain можно пересоздавать, при изменении задач. Чтобы не создавтать его каждый раз с нуля
    // можно указать ссылку на pipelain, который будет использоваться как базовый для нового
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional
    pipelineInfo.basePipelineIndex  = -1;             // Optional

    // pipelineInfo и pipelineInfo могут указывать на массивы
    // это позволяет создавать много pipeline за один вызов
    if(vkCreateGraphicsPipelines(logicalDevice, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS)
        throw std::runtime_error("failed to create graphics pipeline!");

    vkDestroyShaderModule(logicalDevice, fragShaderModule, nullptr);
    vkDestroyShaderModule(logicalDevice, vertShaderModule, nullptr);
}

///////////////////////////////////////////////////////////

void createFramebuffers(VkDevice                       logicalDevice,
                        VkRenderPass                   renderPass,
                        VkExtent2D                     swapChainExtent,
                        const std::vector<VkImageView> &swapChainImageViews,
                        std::vector<VkFramebuffer>     &swapChainFramebuffers,
                        VkImageView                    depthImageView)
{
    swapChainFramebuffers.resize(swapChainImageViews.size());

    for(size_t i = 0; i < swapChainImageViews.size(); i++)
    {
        // вложения буфера. В нашем случае каждый буфер хранит в себе одно изображение из 
        // swap chain
        std::array<VkImageView, 2> attachments = {
            swapChainImageViews[i],
            depthImageView
        };

        VkFramebufferCreateInfo framebufferInfo{};
        framebufferInfo.sType           = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass      = renderPass;
        framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
        framebufferInfo.pAttachments    = attachments.data();
        framebufferInfo.width           = swapChainExtent.width;
        framebufferInfo.height          = swapChainExtent.height;
        framebufferInfo.layers          = 1;

        if(vkCreateFramebuffer(logicalDevice, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS)
            throw std::runtime_error("failed to create framebuffer!");
    }
}

///////////////////////////////////////////////////////////

void createCommandPool(VkPhysicalDevice physicalDevice,
                       VkDevice         logicalDevice,
                       VkSurfaceKHR     surface, 
                       VkCommandPool    &commandPool)
{
    // исполнение командных буферов происходит когда мы отправляем их в одно из семейств очередей
    QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice, surface);

    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType            = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();

    // Возможные флаги:
    // VK_COMMAND_POOL_CREATE_TRANSIENT_BIT - мы говорим что этот буфер будет очень часто перезаписан
    // (вулкан может поменять свое поведение касательно выделения памяти)
    // VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT - позволяет нам перезаписывать только 
    // нужные нам буферы. Без него все буфеы будут очищаться одновременно
    poolInfo.flags = 0; // Optional

    if(vkCreateCommandPool(logicalDevice, &poolInfo, nullptr, &commandPool) != VK_SUCCESS)
        throw std::runtime_error("failed to create command pool!");
}

///////////////////////////////////////////////////////////


void createSyncObjects(VkDevice                   logicalDevice,
                       int                        MAX_FRAMES_IN_FLIGHT,
                       const std::vector<VkImage> &swapChainImages,
                       std::vector<VkSemaphore>   &imageAvailableSemaphores,
                       std::vector<VkSemaphore>   &renderFinishedSemaphores,
                       std::vector<VkFence>       &inFlightFences,
                       std::vector<VkFence>       &imagesInFlight)
{
    imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);
    imagesInFlight.resize(swapChainImages.size(), VK_NULL_HANDLE);

    // согласно текущему состоянию Vulkan API для создания семафора более не требуется никакой
    // информации кроме sType
    VkSemaphoreCreateInfo semaphoreInfo{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    // говорим что при создании наш забор должен быть сразу в сигнальном состоянии
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    for(size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++)
    {
        if(vkCreateSemaphore(logicalDevice, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS ||
           vkCreateSemaphore(logicalDevice, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS ||
           vkCreateFence(logicalDevice, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS)
        {
            throw std::runtime_error("failed to create synchronization objects for a frame!");
        }
    }
}


void createDescriptorPool(VkDevice                   logicalDevice,
                          const std::vector<VkImage> swapChainImages,
                          VkDescriptorPool           &descriptorPool)
{
    std::array<VkDescriptorPoolSize, 2> poolSizes{};

    poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    poolSizes[0].descriptorCount = static_cast<uint32_t>(swapChainImages.size());

    poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    poolSizes[1].descriptorCount = static_cast<uint32_t>(swapChainImages.size());


    VkDescriptorPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
    poolInfo.pPoolSizes    = poolSizes.data();
    poolInfo.maxSets       = static_cast<uint32_t>(swapChainImages.size());


    if(vkCreateDescriptorPool(logicalDevice, &poolInfo, nullptr, &descriptorPool) != VK_SUCCESS)
        throw std::runtime_error("failed to create descriptor pool!");


}

void createDescriptorSets(VkDevice                     logicalDevice,
                          const std::vector<VkImage>   swapChainImages,
                          VkDescriptorPool             descriptorPool,
                          VkDescriptorSetLayout        descriptorSetLayout,
                          std::vector<VkDescriptorSet> &descriptorSets,
                          std::vector<VkBuffer>        &uniformBuffers,
                          VkImageView                  textureImageView,
                          VkSampler                    textureSampler)
{
    std::vector<VkDescriptorSetLayout> layouts(swapChainImages.size(), descriptorSetLayout);
    
    VkDescriptorSetAllocateInfo allocInfo{};
    allocInfo.sType              = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    allocInfo.descriptorPool     = descriptorPool;
    allocInfo.descriptorSetCount = static_cast<uint32_t>(swapChainImages.size());
    allocInfo.pSetLayouts        = layouts.data();

    descriptorSets.resize(swapChainImages.size());
    if(vkAllocateDescriptorSets(logicalDevice, &allocInfo, descriptorSets.data()) != VK_SUCCESS)
        throw std::runtime_error("failed to allocate descriptor sets!");

    for(size_t i = 0; i < swapChainImages.size(); i++)
    {
        VkDescriptorBufferInfo bufferInfo{};
        bufferInfo.buffer = uniformBuffers[i];
        bufferInfo.offset = 0;
        // если мы намерены каждый раз перезаписывать буфер целиком, 
        // то мы можем использовать VK_WHOLE_SIZE для range
        bufferInfo.range = sizeof(UniformBufferObject);

        VkDescriptorImageInfo imageInfo{};
        imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        imageInfo.imageView   = textureImageView;
        imageInfo.sampler     = textureSampler;

        std::array<VkWriteDescriptorSet, 2> descriptorWrites{};

        descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptorWrites[0].dstSet          = descriptorSets[i];
        descriptorWrites[0].dstBinding      = 0;
        descriptorWrites[0].dstArrayElement = 0;
        descriptorWrites[0].descriptorType  = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descriptorWrites[0].descriptorCount = 1;
        descriptorWrites[0].pBufferInfo     = &bufferInfo;

        descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptorWrites[1].dstSet          = descriptorSets[i];
        descriptorWrites[1].dstBinding      = 1;
        descriptorWrites[1].dstArrayElement = 0;
        descriptorWrites[1].descriptorType  = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        descriptorWrites[1].descriptorCount = 1;
        descriptorWrites[1].pImageInfo      = &imageInfo;

        vkUpdateDescriptorSets(logicalDevice, 
                               static_cast<uint32_t>(descriptorWrites.size()), 
                               descriptorWrites.data(), 
                               0, 
                               nullptr);
    }
}

